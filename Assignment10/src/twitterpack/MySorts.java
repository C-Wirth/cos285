package twitterpack;

import java.util.Arrays;

/**
 * Colby Wirth
 * COS 285
 * Version: 8 December 2024
 * This class implements Radix Sort and Merge Sort for Tweet objecct
 */
public class MySorts {

    public static <T extends Comparable<T>> void quickSort(T[] array, int lo, int hi) {

        if (array.length <=1) //recursive base case
            return;

        int pivotIndex = medianOfThree(array,lo,hi);

        partition(array,pivotIndex,lo,hi);


    



        for(T element : array){

            int results = pivotElement.compareTo(element);
            int i = 0;
            int j = 0;

            switch (results) { //this automatically generated by VS Code's Linter from my chain of 'if' statements
                case 1 ->
                {
                    greaterElements[i] = element;
                    i++;
                    break;
                }
                default -> 
                {
                    lesserElements[j] = element;
                    j++;
                    break;
                }
            }
        }

        quickSort(lesserElements);
        quickSort(greaterElements);

        merge(less)
    }



    /**
     * this method gets the pivot point with the median of thee apprach
     * @param array - the array to be sorted. lo - the low INDEX, hi, the high INDEX
     * @return the index of the median pivot point
     */
    private static <T extends Comparable<T>> int medianOfThree(T[] array, int lo, int hi){

        if (hi - lo < 3) { //skip median of three approach if there are less than three elements --- the method will never handle 1 or less elements
            return array[lo].compareTo(array[hi]) > 0 ? hi : lo;
        }

        int lowPoint = lo;
        int highPoint = hi;
        int midPoint = lo + (hi - lo) / 2;

        if (array[lowPoint].compareTo(array[midPoint]) > 0 ){
            int temp = lowPoint;
            lowPoint = midPoint;
            midPoint = temp;
        }
        if (array[midPoint].compareTo(array[highPoint]) > 0){
            int temp = midPoint;
            midPoint=highPoint;
            highPoint=temp;
        }

        if (array[lowPoint].compareTo(array[midPoint]) > 0 ){
            int temp = lowPoint;
            lowPoint = midPoint;
            midPoint=temp;
        }
        
        return midPoint;
    }

    private static <T extends Comparable<T>> void partition(T[] array, int pivotIndex, int lo, int hi){

        swapElement(array,lo,pivotIndex);

        lo = pivotIndex+1;

        while(lo<hi){

            if(array[lo].compareTo(array[pivotIndex]) <=0)
                continue;

            else //array[lo] > array[pivot] - move right pointer until swapping
        }

    }

    /**
     * helper method to handle element swapping
     * @param array - the array, i - the first element to be swapped, j the second element to be swapped
     */
    private static  <T extends Comparable<T>> void swapElement(T[] array, int i, int j){
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }


    public static void insertionSort(int[] input){
        for(int i =1; i < input.length; i++){
            for(int j=i; j>0 && (input[j-1]>input[j]); j--){
                int temp = input[j];
                input[j]=input[j-1];
                input[j-1]=temp;
            }
        }   
    }

    /**
     * Standard merge sort method
     * @param array the inputted array to be sorted
     */
    public static <T extends Comparable<T>> void mergeSort(T[] array) {
        if(array.length <= 1)
            return;

        int mid = array.length /2;
        T[] left = Arrays.copyOfRange(array, 0, mid);
        T[] right = Arrays.copyOfRange(array, mid, array.length);

        mergeSort(left);
        mergeSort(right);

        merge(array,left,right);
    }

    /**
     * helper method for merge sort - merges the split subarrays
     * @param array the current subarray to be merged 
     * @param left the left sub array
     * @param right the  the right sub array
     */
    private static <T extends Comparable<T>> void merge(T[] array, T[] left, T[] right) {
        int leftPointer = 0;
        int rightPointer = 0;
        int i = 0;

        while(leftPointer < left.length || rightPointer < right.length){  //**** WE HAVE VALUES IN LEFT AND RIGHT)

            if(leftPointer >= left.length){ //edge case - left is at end, add right value
                array[i] = right[rightPointer];
                rightPointer++;
                i++;
            }
            else if (rightPointer >= right.length){ //edge case - right is at end, add left value
                array[i] = left[leftPointer];
                leftPointer++;
                i++;
            }

            else if (left[leftPointer].compareTo(right[rightPointer]) < 0) {
                array[i] = left[leftPointer];
                leftPointer++;
                i++;
            }
            else{
                array[i] = right[rightPointer];
                rightPointer++;
                i++;
            }
        }
    }

    public static void printArray(int[] input){
        System.out.println(Arrays.toString(input));
    }
}
