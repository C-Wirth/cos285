package twitterpack;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Author: Colby Wirth 
 * Version: 24 November 2024 
 * Course: COS 285 
 * Class: MySentimentAnalysisModel.java
 */
public class MySentimentAnalysisModel {

    MyHashMap<String, Integer> positive;
    MyHashMap<String, Integer> negative;

    int[]  confusionMatrix; //stores scores of the model once built

    Set<String> STOP_WORDS = new HashSet<>(Arrays.asList(//generated by ChatGPT on 11/23/2024
            "a", "an", "and", "are", "as", "at", "be", "but", "by", 
            "for", "if", "in", "into", "is", "it", "no", "not", "of", 
            "on", "or", "such", "that", "the", "their", "then", 
            "there", "these", "they", "this", "to", "was", "will", "with", 
            "", " "
        ));

    /**
     * Constructor of a MySentimentAnalysisModel 
     * Trains the model with the Tweet objects from a training dataset
     * @param the Hashmap of tweets to evaluate
     */
    public MySentimentAnalysisModel(MyHashMap<Tweet, Boolean> trainData){

        this.positive = new MyHashMap<>();
        this.negative = new MyHashMap<>();

        int i = 0 ;

        for(Tweet key : trainData.keySet()){ //I implemented a keyset() method
            i++;
            addTweetToModel(key, trainData.get(key));
            if(i % 250000 == 0 )
                System.out.println(i + " elements added to the model");
            }

    }

    /**
     * helper method for the constuctor
     * this method handles the processing for a tweet:
     * calls tweetcleaner to perform cleaning tasks
     * tweet to positive or negative MyHashMap based on the tweet's boolean value
     * @param key
     */
    private void addTweetToModel(Tweet key, boolean isPositive){

        String cleanedText = Pattern.compile("[^a-zA-Z\\s]").matcher(key.getText()).replaceAll("");
        String[] cleanedTweet = cleanedText.trim().split("\\s+");

        for(String word : cleanedTweet){

            if(STOP_WORDS.contains(word)) //remove ant stop-words from the tweet
                continue;

            if(isPositive)
                positive.put(word, positive.getOrDefault(word, 0) + 1);
            else
                negative.put(word, negative.getOrDefault(word, 0) + 1);
        }
    }
    
    /**
     * this method reports the statistical scores of the MySentimentAnalysisModel object 
     * when tested against a test set
     * 
     * the model's internal confusion matrix is updated for later retrieval
     * 
     * @param testModel - the data to test the model against
     * @return double - the accuracy score
     */
    public double testModel(MyHashMap<Tweet, Boolean> testData){

        confusionMatrix = new int[4];

        int i = 0;

        for(Tweet tweet : testData.keySet()){

            i++;

            if(i % 500000 == 0)
                System.out.println(i + " entries tested");

            boolean actual_val = testData.get(tweet);
            boolean predict_val = sentimentPredictor(tweet);

            if (actual_val && predict_val) // TP - true positive
                confusionMatrix[0] += 1;
            
            else if (!actual_val && !predict_val) // TN - true negative
                confusionMatrix[1] += 1;
        
            else if (!actual_val && predict_val) // FP - false positive
                confusionMatrix[2] += 1;
        
            else // FN -false negative
                confusionMatrix[3] += 1;
        }
        System.out.println("\n --- \n");

        return getAccuracyScore();
    }

    /**
     * Helper method for testModel()
     * this is the prediction function - trained with the data passed into the constructor 
     * @param the Tweet object
     * @return true if tweet is classified as positve - negative if tweet is classified as negative
     */
    private boolean sentimentPredictor(Tweet tweet){

        String words = Pattern.compile("[^a-zA-Z\\s]").matcher(tweet.getText()).replaceAll("");
        String[] cleanedTweet = (words.split("\\s+"));
        
        int score =0;
        for(String word : cleanedTweet){

            score+= positive.getOrDefault(word, 0);
            score -= negative.getOrDefault(word, 0);
        }
        return score >=0;

    }

    /**
     * Get the accuracy score of the model
     * @return accuracy score - a double - null if model has not been trained
     */
    @SuppressWarnings("null")
    public double getAccuracyScore(){

        if(confusionMatrix == null)
            return (Double) null;
     
        return(double) (confusionMatrix[0] + confusionMatrix[1])
                        /
                        (double) (confusionMatrix[0] + confusionMatrix[1] + confusionMatrix[2] + confusionMatrix[3]);
    }
}

