package twitterpack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Author: Colby Wirth 
 * Version: 24 November 2024 
 * Course: COS 285 
 * Class: MySentimentAnalysisModel.java
 */
public class MySentimentAnalysisModel {

    MyHashMap<String, Integer> positive;
    MyHashMap<String, Integer> negative;

    int[]  confusionMatrix; //stores scores of the model once built

    Set<String> STOP_WORDS = new HashSet<>(Arrays.asList(//generated by ChatGPT on 11/23/2024
            "a", "an", "and", "are", "as", "at", "be", "but", "by", 
            "for", "if", "in", "into", "is", "it", "no", "not", "of", 
            "on", "or", "such", "that", "the", "their", "then", 
            "there", "these", "they", "this", "to", "was", "will", "with", 
            "", " "
        ));

    /**
     * Constructor of a MySentimentAnalysisModel 
     * Trains the model with the Tweet objects from a training dataset
     * @param the Hashmap of tweets to evaluate
     */
    public MySentimentAnalysisModel(MyHashMap<Tweet, Boolean> trainData){

        this.positive = new MyHashMap<>();
        this.negative = new MyHashMap<>();

        int i = 0 ;

        for(Tweet key : trainData.keySet()){ //I implemented a keyset() method
            i++;
            addTweetToModel(key, trainData.get(key));
            if(i % 250000 == 0 )
                System.out.println(i + " elements added to the model");
            }

    }

    /**
     * helper method for the constuctor
     * this method handles the processing for a tweet:
     * calls tweetcleaner to perform cleaning tasks
     * tweet to positive or negative MyHashMap based on the tweet's boolean value
     * @param key
     */
    private void addTweetToModel(Tweet key, boolean isPositive){

        String[] cleanedTweet = tweetCleaner(key.getText());

        for(String word : cleanedTweet){

            if(isPositive)
                positive.put(word, positive.getOrDefault(word, 0) + 1);
            else
                negative.put(word, negative.getOrDefault(word, 0) + 1);
        }
    }

    /**
     * helper method used my multiple methods
     * cleans tweet with regex and removes stopwords
     * @param tweet the String in a Tweet object that represents the text
     * @return the cleaned tweet, an String[]
     */
    private String[] tweetCleaner(String tweet){

        tweet = Pattern.compile("[^a-zA-Z\\s]").matcher(tweet).replaceAll("");

        String[] words = (tweet.split(" "));

        ArrayList<String> cleanedWords = new ArrayList<>(words.length); //use another collection to avoid ConcurrentModificationException

        for(String word : words){
            if(!STOP_WORDS.contains(word))
            cleanedWords.add(word); //filter out stopwords and potential empty tweets
        }
        return cleanedWords.toArray(String[]::new);    }
    
    /**
     * this method reports the statistical scores of the MySentimentAnalysisModel object 
     * when tested against a test set
     * 
     * the model's internal confusion matrix is updated for later retrieval
     * 
     * @param testModel - the data to test the model against
     * @return double - the accuracy score
     */
    public double testModel(MyHashMap<Tweet, Boolean> testData){

        confusionMatrix = new int[4];

        int i = 0;

        for(Tweet tweet : testData.keySet()){

            i++;

            if(i % 500000 == 0)
                System.out.println(i + " entries tested");

            boolean actual_val = testData.get(tweet);
            boolean predict_val = sentimentPredictor(tweet);

            if (actual_val && predict_val) // TP - true positive
                confusionMatrix[0] += 1;
            
            else if (!actual_val && !predict_val) // TN - true negative
                confusionMatrix[1] += 1;
        
            else if (!actual_val && predict_val) // FP - false positive
                confusionMatrix[2] += 1;
        
            else // FN -false negative
                confusionMatrix[3] += 1;
        }
        System.out.println("\n --- \n");

        return getAccuracyScore();
    }

    /**
     * Helper method for testModel()
     * this is the prediction function - trained with the data passed into the constructor 
     * @param the Tweet object
     * @return true if tweet is classified as positve - negative if tweet is classified as negative
     */
    private boolean sentimentPredictor(Tweet tweet){

        String[] cleanedTweet = tweetCleaner(tweet.getText());
        int score =0;

        for(String word : cleanedTweet){

            score+= positive.getOrDefault(word, 0);
            score -= negative.getOrDefault(word, 0);
        }

        return score >=0;

    }

    /**
     * Get the accuracy score of the model
     * @return accuracy score - a double - null if model has not been trained
     */
    @SuppressWarnings("null")
    public double getAccuracyScore(){

        if(confusionMatrix == null)
            return (Double) null;
     
        return(double) (confusionMatrix[0] + confusionMatrix[1])
                        /
                        (double) (confusionMatrix[0] + confusionMatrix[1] + confusionMatrix[2] + confusionMatrix[3]);
    }
}

