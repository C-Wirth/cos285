package twitterpack;

import java.util.Arrays;

/**
 * Author: Colby Wirth 
 * Version: 30 November 2024 
 * Course: COS 285 
 * Class: MyHeap.java
 * This implementation is for a min heap
 */
public class MyHeap<T extends Comparable<T>> {

    private T[] heap;
    private int size;

    /**
     * Constructor
     * Instantiate the inner array
     */
    @SuppressWarnings("unchecked")
    public MyHeap(){
        this.heap = (T[]) new Comparable[10];
        size = 0;

    }

    /**
     * add method adds an element to the inner heap, then calls heapify to reorganzie the heap array based on comparator definition
     * @param key
     */
    public void add(T key){
        if (size == heap.length) {
            resize();
        }

        heap[size] = key;
        size++;
        heapifyUp();
    }

    private void resize(){
        T[] newHeap = (T[]) new Comparable[heap.length * 2];
        System.arraycopy(heap, 0, newHeap, 0, heap.length);
        heap = newHeap;
    }

    /**
     * This method heapifies a heap after adding an element comparator (min heap)
     */
    private void heapifyUp(){

        int currentIndex = size -1;

        while(currentIndex > 0){
            int parentIndex = findParent(currentIndex); 
        
            if (heap[currentIndex].compareTo(heap[parentIndex]) < 0) {
                swap(currentIndex, parentIndex); 
                currentIndex = parentIndex;
            } else {
                break; 
            }
        }
    }

    /**
     * helper method to find the parent node of a specified node
     * @param index - the location of the node
     * 
     * @return parentIndex the index of the parent node | or if the given index is the root, the returned index will be -1
     */
    public int findParent(int index){

        if(index == 0)
            return -1;

        else // Java's integer division truncates and simplifies the operations
            return (index-1)/2;
    }

    /**
     * delete method polls the top element, puts last element in position 0 and then calls heapifyDown to fix the heap
     * @return T the top element polled
     */
    public T delete(){

        T deletedElement = heap[0];
        size--;

        switch (size) { //this automatically generated by VS Code's Linter from my chain of 'if' statements
            case -1 -> throw new IllegalStateException("No elements to delete");
            case 0 -> heap[0] = null;
            default -> {
                heap[0] = heap[size];
                heap[size] = null;
                heapifyDown();
            }
        }
        return deletedElement;
    }

    /**
     * swap elements iteratively
     */
    private void heapifyDown(){

        int parentIndex = 0;

        while(true) {
            int leftChild = 2*parentIndex + 1;
            int rightChild = 2*parentIndex + 2;
            int nextChild = parentIndex;

            if (leftChild < size && heap[leftChild].compareTo(heap[nextChild]) < 0)
                nextChild = leftChild;
            
            if (rightChild < size && heap[rightChild].compareTo(heap[nextChild]) < 0) 
                nextChild = rightChild;
                
            if(nextChild == parentIndex)
                break;
                
            swap(parentIndex, nextChild);
            parentIndex = nextChild;
        }
    }

    /**
     * helper method for heapifyUp and heapifyDown
     * @param p parent index
     * @param c child index
     */
    @SuppressWarnings("unchecked")
    public void swap(int p, int c){
        T temp = heap[p]; 
        heap[p] = heap[c];
        heap[c]= (T) temp;
    }

    /**
     * isEmpty method 
     * @return True - is Empty - False otherwise
     */
    public boolean isEmpty(){
        return size == 0;
    }

    /**
     * size method gets the number of elements in the hidden heap
     * @return the number of elements in the heap
     */
    public int size(){
        return size;
    }

    /**
     * Peek method gets the top element of the MyHeap
     * @return heap[0] this is the top element of the MyHeap, always
     */
    public T peek(){
        return heap[0];
    }

    /**
     * toString for debugging, print the inner array
     */
    @Override
    public String toString() {
        return Arrays.toString(heap);
    }
}